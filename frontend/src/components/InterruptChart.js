'use client';

import { useState, useEffect, useMemo } from 'react';
import dynamic from 'next/dynamic';
import styles from './InterruptChart.module.css';

// ImportaÃ§Ã£o dinÃ¢mica dos componentes de grÃ¡fico
const ChartRenderer = dynamic(() => import('./ChartRenderer'), { 
  ssr: false,
  loading: () => (
    <div style={{ 
      height: '400px', 
      display: 'flex', 
      alignItems: 'center', 
      justifyContent: 'center', 
      background: '#f8f9fa', 
      border: '1px dashed #dee2e6', 
      borderRadius: '4px' 
    }}>
      <p style={{ color: '#2c3e50', fontSize: '16px', fontWeight: '500' }}>ğŸ“Š Carregando grÃ¡fico...</p>
    </div>
  )
});

const TemporalChart = dynamic(() => import('./TemporalChart'), { 
  ssr: false,
  loading: () => (
    <div style={{ 
      height: '200px', 
      display: 'flex', 
      alignItems: 'center', 
      justifyContent: 'center', 
      background: '#f8f9fa', 
      border: '1px dashed #dee2e6', 
      borderRadius: '4px' 
    }}>
      <p style={{ color: '#2c3e50', fontSize: '16px', fontWeight: '500' }}>ğŸ“ˆ Carregando grÃ¡fico temporal...</p>
    </div>
  )
});

const MemoryChart = dynamic(() => import('./MemoryChart'), { 
  ssr: false,
  loading: () => (
    <div style={{ 
      height: '200px', 
      display: 'flex', 
      alignItems: 'center', 
      justifyContent: 'center', 
      background: '#f8f9fa', 
      border: '1px dashed #dee2e6', 
      borderRadius: '4px' 
    }}>
      <p style={{ color: '#2c3e50', fontSize: '16px', fontWeight: '500' }}>ğŸ’¾ Carregando grÃ¡fico de memÃ³ria...</p>
    </div>
  )
});

// FunÃ§Ã£o para formataÃ§Ã£o consistente de nÃºmeros (evita problemas de hidrataÃ§Ã£o)
const formatNumber = (num) => {
  if (typeof num !== 'number') return '0';
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
};

// FunÃ§Ã£o para converter KB para GB
const kbToGb = (kb) => {
  if (typeof kb !== 'number') return 0;
  return (kb / 1024 / 1024);
};

// FunÃ§Ã£o para formatear tamanho de memÃ³ria
const formatMemorySize = (kb) => {
  const gb = kbToGb(kb);
  if (gb >= 1) {
    return `${gb.toFixed(2)} GB`;
  } else {
    const mb = kb / 1024;
    return `${mb.toFixed(0)} MB`;
  }
};

// DescriÃ§Ãµes das mÃ©tricas de memÃ³ria
const memoriaDescricoes = {
  'total': 'Quantidade total de memÃ³ria RAM fÃ­sica instalada no sistema',
  'disponivel': 'MemÃ³ria utilizÃ¡vel por novas aplicaÃ§Ãµes, incluindo RAM livre e cache liberÃ¡vel pelo kernel',
  'livre': 'MemÃ³ria completamente nÃ£o utilizada, sem dados ou cache. PorÃ§Ã£o da RAM que estÃ¡ completamente vazia',
  'uso': 'Percentual efetivo de uso: (Total - DisponÃ­vel) / Total. Indica memÃ³ria ativamente utilizada nÃ£o liberÃ¡vel'
};

// DescriÃ§Ãµes das mÃ©tricas de swap
const swapDescricoes = {
  'total': 'Tamanho total do espaÃ§o de swap (arquivo de paginaÃ§Ã£o ou partiÃ§Ã£o de swap)',
  'usado': 'Quantidade de swap em uso. Valores altos indicam pouca RAM disponÃ­vel',
  'livre': 'EspaÃ§o de swap disponÃ­vel. Usado quando RAM estÃ¡ cheia, movendo dados menos usados para disco',
  'uso': 'Percentual do swap em uso. Valores altos podem indicar necessidade de mais RAM'
};

// DescriÃ§Ãµes das categorias de interrupÃ§Ã£o
const categoriaDescricoes = {
  'rede': 'ComunicaÃ§Ã£o e transferÃªncia de dados atravÃ©s de conexÃµes de rede local, Wi-Fi, internet e outros protocolos de comunicaÃ§Ã£o entre dispositivos',
  'armazenamento': 'OperaÃ§Ãµes de leitura e escrita de dados em discos rÃ­gidos, SSDs, pendrives e outros dispositivos de armazenamento de dados',
  'usb': 'Gerenciamento e comunicaÃ§Ã£o com dispositivos conectados atravÃ©s de portas USB, incluindo transferÃªncia de dados e fornecimento de energia',
  'entrada': 'Captura de comandos e interaÃ§Ãµes do usuÃ¡rio atravÃ©s de teclados, mouses, touchpads, joysticks e outros dispositivos de entrada',
  'gpu': 'Processamento grÃ¡fico, renderizaÃ§Ã£o de imagens, aceleraÃ§Ã£o de vÃ­deo e cÃ¡lculos paralelos realizados pela placa de vÃ­deo',
  'audio': 'Processamento de som, reproduÃ§Ã£o e gravaÃ§Ã£o de Ã¡udio, controle de volume e comunicaÃ§Ã£o com dispositivos sonoros',
  'energia': 'Gerenciamento de consumo energÃ©tico, controle tÃ©rmico, ajuste de frequÃªncias do processador e otimizaÃ§Ã£o da bateria',
  'temporizador': 'SincronizaÃ§Ã£o temporal do sistema, agendamento de tarefas, controle de relÃ³gio e eventos baseados em tempo',
  'inter-cpu': 'ComunicaÃ§Ã£o e coordenaÃ§Ã£o entre mÃºltiplos nÃºcleos do processador para distribuiÃ§Ã£o de tarefas e sincronizaÃ§Ã£o',
  'kernel': 'OperaÃ§Ãµes internas crÃ­ticas do sistema operacional, tratamento de erros, monitoramento de desempenho e funÃ§Ãµes essenciais',
  'pcie': 'ComunicaÃ§Ã£o com dispositivos conectados via PCIe, incluindo placas de expansÃ£o, dispositivos Thunderbolt e componentes de alta velocidade',
  'virtualizacao': 'Suporte a mÃ¡quinas virtuais, containers e ambientes virtualizados, facilitando a execuÃ§Ã£o de mÃºltiplos sistemas',
  'gpio': 'Controle de pinos de entrada/saÃ­da de uso geral, sensores, LEDs e outros dispositivos eletrÃ´nicos de baixo nÃ­vel',
  'sistema': 'OperaÃ§Ãµes fundamentais do sistema operacional e interrupÃ§Ãµes que nÃ£o se enquadram em categorias especÃ­ficas'
};

export default function InterruptChart({ data }) {
  const [selectedCores, setSelectedCores] = useState([]);
  const [selectedCategories, setSelectedCategories] = useState([]);
  const [viewMode, setViewMode] = useState('cores'); // 'cores' ou 'categorias'
  
  // NÃ£o inicializar automaticamente - comeÃ§ar sempre vazio
  // useEffect removido para comeÃ§ar com seleÃ§Ãµes vazias

  // Limpar seleÃ§Ãµes e comeÃ§ar vazio quando o modo de visualizaÃ§Ã£o mudar
  useEffect(() => {
    setSelectedCores([]);
    setSelectedCategories([]);
  }, [viewMode]);

  // Limpar seleÃ§Ãµes invÃ¡lidas quando os dados mudam
  useEffect(() => {
    if (!data) return;
    
    // Limpar nÃºcleos que nÃ£o existem nos dados
    if (data.por_cpu) {
      const availableCores = Object.keys(data.por_cpu);
      setSelectedCores(prev => prev.filter(core => availableCores.includes(core)));
    }
    
    // Limpar categorias que nÃ£o existem nos dados
    if (data.por_categoria) {
      const availableCategories = Object.keys(data.por_categoria);
      setSelectedCategories(prev => prev.filter(categoria => availableCategories.includes(categoria)));
    }
  }, [data]);

  // Processar dados para o grÃ¡fico por cores
  const chartDataByCores = useMemo(() => {
    if (!data || !data.por_cpu || selectedCores.length === 0) return [];
    
    return selectedCores.map(core => ({
      name: `NÃºcleo ${core}`,
      core: core,
      interrupcoes: data.por_cpu[core] || 0
    }));
  }, [data, selectedCores]);

  // Processar dados para o grÃ¡fico por categorias
  const chartDataByCategories = useMemo(() => {
    if (!data || !data.por_categoria || selectedCategories.length === 0) return [];
    
    // No modo categorias, usar todos os cores se nenhum estiver selecionado
    const coresToUse = viewMode === 'categorias' && selectedCores.length === 0 
      ? Object.keys(data.por_cpu || {})
      : selectedCores;
    
    if (coresToUse.length === 0) return [];
    
    return selectedCategories
      .filter(categoria => data.por_categoria[categoria]) // Filtrar categorias que existem nos dados
      .map(categoria => {
        const categoriaData = data.por_categoria[categoria];
        const total = coresToUse.reduce((sum, core) => {
          return sum + (categoriaData[core] || 0);
        }, 0);
        
        return {
          name: categoria.charAt(0).toUpperCase() + categoria.slice(1),
          categoria: categoria,
          interrupcoes: total
        };
      });
  }, [data, selectedCategories, selectedCores, viewMode]);

  // Processar dados para grÃ¡fico detalhado (categoria por core)
  const chartDataDetailed = useMemo(() => {
    if (!data || !data.por_categoria || selectedCategories.length === 0) return [];
    
    // No modo detalhado, exigir que pelo menos um core esteja selecionado
    if (selectedCores.length === 0) return [];
    
    return selectedCores.map(core => {
      const coreData = { name: `NÃºcleo ${core}`, core: core };
      
      selectedCategories.forEach(categoria => {
        // Verificar se a categoria existe nos dados antes de acessar
        if (data.por_categoria[categoria]) {
          coreData[categoria] = data.por_categoria[categoria][core] || 0;
        } else {
          coreData[categoria] = 0; // Valor padrÃ£o se a categoria nÃ£o existir
        }
      });
      
      return coreData;
    });
  }, [data, selectedCategories, selectedCores]);

  const handleCoreToggle = (core) => {
    setSelectedCores(prev => 
      prev.includes(core) 
        ? prev.filter(c => c !== core)
        : [...prev, core]
    );
  };

  const handleCategoryToggle = (category) => {
    setSelectedCategories(prev => 
      prev.includes(category) 
        ? prev.filter(c => c !== category)
        : [...prev, category]
    );
  };

  const selectAllCores = () => {
    if (data && data.por_cpu) {
      const allCores = Object.keys(data.por_cpu);
      // Se todos os cores estÃ£o selecionados, desmarca todos; senÃ£o, seleciona todos
      if (selectedCores.length === allCores.length && allCores.every(core => selectedCores.includes(core))) {
        setSelectedCores([]);
      } else {
        setSelectedCores(allCores);
      }
    }
  };

  const selectAllCategories = () => {
    if (data && data.por_categoria) {
      const allCategories = Object.keys(data.por_categoria);
      // Se todas as categorias estÃ£o selecionadas, desmarca todas; senÃ£o, seleciona todas
      if (selectedCategories.length === allCategories.length && allCategories.every(cat => selectedCategories.includes(cat))) {
        setSelectedCategories([]);
      } else {
        setSelectedCategories(allCategories);
      }
    }
  };

  if (!data) {
    return <div className={styles.loading}>Carregando dados das interrupÃ§Ãµes...</div>;
  }

  const cores = data.por_cpu ? Object.keys(data.por_cpu) : [];
  const categorias = data.por_categoria ? Object.keys(data.por_categoria) : [];

  // FunÃ§Ã£o para determinar o texto do botÃ£o de cores
  const getCoreButtonText = () => {
    if (cores.length === 0) return 'Selecionar Todos os NÃºcleos';
    const allSelected = selectedCores.length === cores.length && cores.every(core => selectedCores.includes(core));
    return allSelected ? 'Desmarcar Todos os NÃºcleos' : 'Selecionar Todos os NÃºcleos';
  };

  // FunÃ§Ã£o para determinar o texto do botÃ£o de categorias
  const getCategoryButtonText = () => {
    if (categorias.length === 0) return 'Selecionar Todas as Categorias';
    const allSelected = selectedCategories.length === categorias.length && categorias.every(cat => selectedCategories.includes(cat));
    return allSelected ? 'Desmarcar Todas as Categorias' : 'Selecionar Todas as Categorias';
  };

  return (
    <div className={styles['interrupt-chart']}>
      <div className={styles.controls}>
        <div className={styles['view-mode']}>
          <h3>Modo de VisualizaÃ§Ã£o</h3>
          <div className={styles['radio-group']}>
            <label>
              <input
                type="radio"
                value="cores"
                checked={viewMode === 'cores'}
                onChange={(e) => setViewMode(e.target.value)}
              />
              Por NÃºcleos
            </label>
            <label>
              <input
                type="radio"
                value="categorias"
                checked={viewMode === 'categorias'}
                onChange={(e) => setViewMode(e.target.value)}
              />
              Por Categorias
            </label>
            <label>
              <input
                type="radio"
                value="detalhado"
                checked={viewMode === 'detalhado'}
                onChange={(e) => setViewMode(e.target.value)}
              />
              Detalhado (Categoria por NÃºcleo)
            </label>
          </div>
        </div>

        <div className={styles.filters}>
          {/* Mostrar filtro de cores apenas nos modos que precisam */}
          {(viewMode === 'cores' || viewMode === 'detalhado') && (
            <div className={styles['core-selection']}>
              <h3>NÃºcleos do Processador</h3>
              <button onClick={selectAllCores} className={styles['select-all']}>
                {getCoreButtonText()}
              </button>
              <div className={styles['checkbox-grid']}>
                {cores.map(core => (
                  <label key={core} className={styles['checkbox-item']}>
                    <input
                      type="checkbox"
                      checked={selectedCores.includes(core)}
                      onChange={() => handleCoreToggle(core)}
                    />
                    NÃºcleo {core}
                  </label>
                ))}
              </div>
            </div>
          )}

          {/* Mostrar filtro de categorias apenas nos modos que precisam */}
          {(viewMode === 'categorias' || viewMode === 'detalhado') && (
            <div className={styles['category-selection']}>
              <h3>Tipos de InterrupÃ§Ã£o</h3>
              <button onClick={selectAllCategories} className={styles['select-all']}>
                {getCategoryButtonText()}
              </button>
              <div className={styles['checkbox-grid']}>
                {categorias.map(categoria => (
                  <label key={categoria} className={styles['checkbox-item']}>
                    <input
                      type="checkbox"
                      checked={selectedCategories.includes(categoria)}
                      onChange={() => handleCategoryToggle(categoria)}
                    />
                    <span className={styles['category-label']}>
                      {categoria.charAt(0).toUpperCase() + categoria.slice(1)}
                      <span 
                        className={styles['tooltip-icon']}
                        title={categoriaDescricoes[categoria] || 'DescriÃ§Ã£o nÃ£o disponÃ­vel'}
                      >
                        ?
                      </span>
                    </span>
                  </label>
                ))}
              </div>
            </div>
          )}
        </div>
      </div>

      <div className={styles['chart-container']}>
        <ChartRenderer 
          viewMode={viewMode}
          chartDataByCores={chartDataByCores}
          chartDataByCategories={chartDataByCategories}
          chartDataDetailed={chartDataDetailed}
          selectedCategories={selectedCategories}
        />
      </div>

      {(viewMode === 'cores' || viewMode === 'categorias') && (
        <TemporalChart 
          data={data}
          selectedCores={selectedCores}
          selectedCategories={selectedCategories}
          viewMode={viewMode}
        />
      )}

      <MemoryChart data={data} />

      <div className={styles.stats}>
        <div className={styles['stat-item']}>
          <h4>UtilizaÃ§Ã£o da CPU</h4>
          <p className={styles['cpu-usage']}>Utilizando: {(data.interrupcoes_tempo?.util * 100 || 0).toFixed(2)}%</p>
          <p className={styles['cpu-idle']}>Ocioso: {(data.interrupcoes_tempo?.ocioso * 100 || 0).toFixed(2)}%</p>
        </div>
        <div className={styles['stat-item']}>
          <h4>Trocas de Contexto</h4>
          <p className={styles['context-switches']}>{formatNumber(data.trocas_de_contexto || 0)}</p>
        </div>
        {data.memoria && (
          <>
            <div className={styles['stat-item']}>
              <h4>MemÃ³ria RAM</h4>
              <p className={styles['memory-total']}>
                Total: {formatMemorySize(data.memoria.mem_total_kb)}
                <span 
                  className={styles['tooltip-icon']}
                  title={memoriaDescricoes['total']}
                >
                  ?
                </span>
              </p>
              <p className={styles['memory-available']}>
                DisponÃ­vel: {formatMemorySize(data.memoria.mem_available_kb)}
                <span 
                  className={styles['tooltip-icon']}
                  title={memoriaDescricoes['disponivel']}
                >
                  ?
                </span>
              </p>
              <p className={styles['memory-free']}>
                Livre: {formatMemorySize(data.memoria.mem_free_kb)}
                <span 
                  className={styles['tooltip-icon']}
                  title={memoriaDescricoes['livre']}
                >
                  ?
                </span>
              </p>
              <p className={styles['memory-usage-percent']}>
                Uso: {(((data.memoria.mem_total_kb - data.memoria.mem_available_kb) / data.memoria.mem_total_kb) * 100).toFixed(1)}%
                <span 
                  className={styles['tooltip-icon']}
                  title={memoriaDescricoes['uso']}
                >
                  ?
                </span>
              </p>
            </div>
            <div className={styles['stat-item']}>
              <h4>MemÃ³ria Swap</h4>
              <p className={styles['swap-total']}>
                Total: {formatMemorySize(data.memoria.swap_total_kb)}
                <span 
                  className={styles['tooltip-icon']}
                  title={swapDescricoes['total']}
                >
                  ?
                </span>
              </p>
              <p className={styles['swap-used']}>
                Usado: {formatMemorySize(data.memoria.swap_total_kb - data.memoria.swap_free_kb)}
                <span 
                  className={styles['tooltip-icon']}
                  title={swapDescricoes['usado']}
                >
                  ?
                </span>
              </p>
              <p className={styles['swap-free']}>
                Livre: {formatMemorySize(data.memoria.swap_free_kb)}
                <span 
                  className={styles['tooltip-icon']}
                  title={swapDescricoes['livre']}
                >
                  ?
                </span>
              </p>
              <p className={styles['swap-usage-percent']}>
                Uso: {data.memoria.swap_total_kb > 0 ? (((data.memoria.swap_total_kb - data.memoria.swap_free_kb) / data.memoria.swap_total_kb) * 100).toFixed(1) : 0}%
                <span 
                  className={styles['tooltip-icon']}
                  title={swapDescricoes['uso']}
                >
                  ?
                </span>
              </p>
            </div>
          </>
        )}
      </div>
    </div>
  );
}
